# Extraction of Elements
M[1, 2] # extracts element from the 1st row and 2nd column
M[1, ] # extracts 1st row
M[, 3] # extracts 3rd column
# Row & Column Operations
apply(M, 1, mean ) # 1 for row operations
apply(M, 2, mean ) # 2 for column operations
# Extract all elements less than 7 from 2nd column of M
y = M[, 2]
y[y < 7]
# Basic Operations
X1 + X2 # element wise addition
X1 - X2 # element wise subtraction
X1 * X2 # element wise multiplication
x1
x2
M
# Dataframes in R
day.num = seq(1, 7, 1)
day.name = c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat")
week = data.frame(day.num, day.name)
week
week.mat = as.matrix( week )
is.matrix(week.mat) # TRUE
# Accessing elements
head(airquality)
is.data.frame(airquality)
airquality$Wind
airquality$Temp
# Creating lists
y = vector(mode = "list")
y[[1]] = c(1, 2, 3)
y[[2]] = c(5, "apple", 6, "banana", 7, "cherry")
y[[3]] = c("Welcome to 2nd lecture - intro to R")
y[[4]] = matrix (c(1, 2, 3, 4), nrow = 2)
y[[5]] = y[[1]] + 10
y
# Giving names
names(y) = c("numbers", "mix", "sentence", "matrix1", "matrix2")
# Nested lists
z = vector(mode = "list")
z[[1]] = vector(mode = "list")
z[[1]][[1]] = c("Monday")
z[[1]][[2]] = c("Tuesday")
z[[1]][[3]] = c("Wednesday")
z[[1]][[4]] = c("Thursday")
z[[1]][[5]] = c("Friday")
z[[2]] = vector(mode = "list")
z[[2]][[1]] = c("Saturday")
z[[2]][[2]] = c("Sunday")
z[[3]] = list(seq(0.1 , 0.2 , length = 10))
names(z) = c("weekdays", "weekend", "sequence")
z
# Accessing elements
z$weekdays[[5]]
z$weekend[[2]]
z$sequence[[1]][5]
# If-else statement
x = 10
if (x %% 2 == 0) {
y = runif(n = 1, min = 0, max = 1)
} else {
y = runif(n = 1, min = 2, max = 4)
}
y
ifelse(x %% 2 == 0, runif(1, 0, 1), runif(1, 2, 4))
x = 15
if (x %% 2 == 0) {
y = runif(n = 1, min = 0, max = 1)
} else if (x %% 3 == 0) {
y = 0
} else {
y = runif(n = 1, min = 2, max = 4)
}
y
# Writing loops
count = 1 # Initialize count
z = NULL
while (count <= 15)
# The task within while loop is executed until
# count becomes 16
{
# Creating a vector
x = c(1:count)
# Storing 1st element of a random permutation
y = sample(x)[1]
# Storing all the 1st elements
# of each random permutation
z = c(z, y)
# Increasing the count
count = count + 1
# Extremely important step to run the loop
}
z
for (i in 1:10) {
if(i %% 2 == 0) {
print(i)
} else {
print(0)
}
}
# Fibonacci sequence
f = NULL
f[1] = 1
f[2] = 1
for (j in 3:20) {
f[j] = f[j - 1] + f[j - 2]
}
f
# sapply and lapply
sapply (1:5 , function(i) {
mean(runif(10 , min = i, max = i + 1))
})
lapply (1:5 , function(i) {
mean(runif(10 , min = i, max = i + 1))
})
?CO2
head(CO2)
is.data.frame(CO2)
CO2$Plant
CO2$Type
CO2$Treatment
CO2$conc
CO2$uptake
# Extract the update values for which Plant equals Qn1
CO2$uptake[CO2$Plant == "Qn1"]
# Extract the update values for which Plant equals Qn1 and Type equals Quebec. Also calculate the mean
CO2$uptake[(CO2$Plant == "Qn1") & (CO2$Type == "Quebec")]
mean(CO2$uptake[(CO2$Plant == "Qn1") & (CO2$Type == "Quebec")])
# Calculate how many uptake values are there which are less than 25
sum(ifelse(CO2$uptake <= 25, 1, 0))
# For loop
count1 = NULL
for(k in 1:length(CO2$uptake)) {
if(CO2$Treatment[k] == "chilled" & CO2$uptake[k] <= 25) {
count1[k] = 1
} else {
count1[k] = 0
}
}
sum(count1)
# While loop
k = 1
count2 = NULL
while (k <= length(CO2$uptake)) {
if(CO2$Treatment[k] == "chilled" & CO2$uptake[k] <= 25) {
count2[k] = 1
} else {
count2[k] = 0
}
k = k + 1
}
sum(count2)
# Calculate the average distance taken to stop given the speed of the cars using lapply and sapply
speed = unique(cars$speed)
lapply(1:length(speed), function(h){
x = mean(cars$dist[cars$speed == speed[h]])
return(x)
})
speed = unique(cars$speed)
sapply(1:length(speed), function(h){
y = mean(cars$dist[cars$speed == speed[h]])
return(y)
})
# Writing simple functions
average.sd = function(n) {
# Check if n >= 10
if(n >= 10) {
x = sample(1:n, size = 10, replace = FALSE)
} else{
# if false generate error message
stop("Enter number more than 10")
}
# Calculate mean and standard deviation
y1 = mean(x)
y2 = var(x)
y = c(y1, y2)
return(y) # Return statement
}
average.sd(4) # Function calls
average.sd(11)
average.sd(20)
# Function body
f = function(x) {
return(x^2 - 3*x + 4)
}
# Generate x values to evaluate the function
xval = seq(0, 1, length = 20)
yval = f(x = xval) # Function call
# Plot the curve
plot(xval, yval, type = "l", xlab = "x", ylab = "f(x)")
# Data Visualization
# Scatter Plot
x = cars$speed
y = cars$dist
plot(x, y, col = "maroon", pch = 16, xlab = "speed", ylab = "distance",
main = "Scatter Plot of distance vs speed")
library (ggplot2)
ggplot(cars, aes(x = speed, y = dist)) + geom_point () + ggtitle (" Scatter Plot of distance vs speed ")
# Line diagram
ggplot(cars, aes(x = speed, y = dist)) + geom_line() + ggtitle("Line Diagram of distance vs speed")
# Bar Plot
# Calculate the average mpg values corresponding
# to each cylinder value
# Three categories
mpg1 = mean(mtcars$mpg[mtcars$cyl == 4])
mpg2 = mean(mtcars$mpg[mtcars$cyl == 6])
mpg3 = mean(mtcars$mpg[mtcars$cyl == 8])
barplot(c(mpg1, mpg2, mpg3) ~ c(4, 6, 8),
xlab = "mtcars$cyl",
ylab = "average mpg per cyl",
ylim = c(0, 28),
col = "maroon",  # color of the bars
width = c(5, 5, 5),  # width of the bars
space = 2, # bar spacing
main = "Barplot for average mpg vs cyl")
cyl = c(4, 6, 8)
avg.mpg = c(mpg1, mpg2, mpg3)
data = data.frame(cyl, avg.mpg)
ggplot(data, aes(y = avg.mpg , x = cyl)) +
geom_bar(position = "dodge", stat="identity") +
ggtitle("Barplot for average mpg vs cyl for mtcars") +
ylim(c(0, 28))
# Divided Bar Diagram
mpg1 = mean(mtcars$mpg[mtcars$cyl == 4])
mpg2 = mean(mtcars$mpg[mtcars$cyl == 6])
mpg3 = mean(mtcars$mpg[mtcars$cyl == 8])
disp1 = mean(mtcars$disp[mtcars$cyl == 4])
disp2 = mean(mtcars$disp[mtcars$cyl == 6])
disp3 = mean(mtcars$disp[mtcars$cyl == 8])
hp1 = mean(mtcars$hp[mtcars$cyl == 4])
hp2 = mean(mtcars$hp[mtcars$cyl == 6])
hp3 = mean(mtcars$hp[mtcars$cyl == 8])
qsec1 = mean(mtcars$qsec[mtcars$cyl == 4])
qsec2 = mean(mtcars$qsec[mtcars$cyl == 6])
qsec3 = mean(mtcars$qsec[mtcars$cyl == 8])
cyl = c(4, 6, 8)
avg.mpg = c(mpg1, mpg2, mpg3)
avg.disp = c(disp1, disp2, disp3)
avg.hp = c(hp1, hp2, hp3)
avg.qsec = c(qsec1, qsec2, qsec3)
mtcars.mat = rbind(avg.mpg, avg.disp, avg.hp, avg.qsec)
colnames(mtcars.mat) = c("4", "6", "8")
barplot(mtcars.mat,
col = c("skyblue", "deepskyblue2", "dodgerblue4", "blue"),
ylim = c(0, 650),
legend.text = rownames(mtcars.mat),
args.legend = list(x = "topleft"),
main = "Divided Barplot for mtcars")
# Multiple Bar Diagram
barplot(mtcars.mat,
col = c("skyblue", "deepskyblue2", "dodgerblue4", "blue"),
ylim = c(0, 350),
legend.text = rownames(mtcars.mat),
args.legend = list(x = "topleft"),
main = "Multiple Bardiagram for mtcars",
beside = TRUE)
# Pie Diagram
# Calculating averages
food.tobacco = mean(USPersonalExpenditure[1, ])
house.opr = mean(USPersonalExpenditure[2, ])
med.health = mean(USPersonalExpenditure[3, ])
per.care = mean(USPersonalExpenditure[4, ])
prvt.edu = mean(USPersonalExpenditure[5, ])
# Pie diagram
avg.exp = c(food.tobacco, house.opr, med.health, per.care, prvt.edu)
categories = c("food.tobacco", "household.operation", "medical.health", "personal.care", "private.education")
pie(avg.exp, labels = categories, main = "Average personal expenditures over years")
# Box plot
boxplot(mtcars$hp ~ as.factor(mtcars$cyl), col = "skyblue",
xlab = "Cylinders",
ylab = "Horse Power",
main = "Boxplot for hp by cyl for mtcars")
# Histogram
hist(faithful$eruptions, freq = FALSE,
xlab = "Eruption time",
main = "Histogram for eruptions data")
pie(avg.exp, labels = categories, main = "Average personal expenditures over years")
locs=matrix(1:5,ncol=1);vecchia_specify(locs,m=2)
library(GPvecchia)
locs=matrix(1:5,ncol=1);vecchia_specify(locs,m=2)
v=vecchia_specify(locs,m=2)
str(v)
install.packages("installr")
library(installr)
updateR()
hist(rnorm(1000))
hist(rnorm(1000, 0, 2))
hist(rnorm(1000), xlim = c(-7, 7))
hist(rnorm(1000, 0, 2), xlim = c(-7, 7))
hist(rnorm(1000, 0, 3), xlim = c(-7, 7))
hist(rnorm(1000), xlim = c(-7, 7), ylim = c(0, 175))
hist(rnorm(1000, 0, 2), xlim = c(-7, 7), ylim = c(0, 175))
hist(rnorm(1000, 0, 3), xlim = c(-7, 7), ylim = c(0, 175))
hist(rnorm(1000), xlim = c(-7, 7), ylim = c(0, 250))
hist(rnorm(1000, 0, 2), xlim = c(-7, 7), ylim = c(0, 250))
hist(rnorm(1000, 0, 3), xlim = c(-7, 7), ylim = c(0, 250))
hist(rnorm(1000), main="")
hist(rnorm(1000), main="", xlim=c(-7,7), ylim=c(0,300))
hist(rnorm(1000, 0, 2), main="", xlim=c(-7,7), ylim=c(0,300))
hist(rnorm(1000, 0, 5), main="", xlim=c(-7,7), ylim=c(0,300))
hist(rnorm(1000, 0, 3), main="", xlim=c(-7,7), ylim=c(0,300))
hist(rnorm(1000), main="", xlim=c(-7,7), ylim=c(0,300))
hist(rnorm(1000), main="", xlim=c(-7,7), ylim=c(0,300), breaks=20)
hist(rnorm(1000, 0, 2), main="", xlim=c(-7,7), ylim=c(0,300), breaks=20)
hist(rnorm(1000, 0, 3), main="", xlim=c(-7,7), ylim=c(0,300), breaks=20)
hist(rnorm(1000), main="", xlim=c(-7,7), ylim=c(0,300), breaks=20)
hist(rnorm(1000, 0, 2), main="", xlim=c(-7,7), ylim=c(0,300), breaks=20)
hist(rnorm(1000, 0, 3), main="", xlim=c(-7,7), ylim=c(0,300), breaks=20)
hist(rnorm(1000), main="", xlim=c(-7,7), ylim=c(0,200), breaks=20)
hist(rnorm(1000, 0, 2), main="", xlim=c(-7,7), ylim=c(0,200), breaks=20)
hist(rnorm(1000, 0, 3), main="", xlim=c(-7,7), ylim=c(0,200), breaks=20)
hist(rnorm(1000), main="", xlim=c(-7,7), ylim=c(0,220), breaks=20)
hist(rnorm(1000, 0, 2), main="", xlim=c(-7,7), ylim=c(0,220), breaks=20)
hist(rnorm(1000, 0, 3), main="", xlim=c(-7,7), ylim=c(0,220), breaks=20)
par(mfrow=c(1,3))
hist(rnorm(1000), main="Histogram A", xlim=c(-7,7), ylim=c(0,220), breaks=20)
hist(rnorm(1000, 0, 2), main="Histogram B", xlim=c(-7,7), ylim=c(0,220), breaks=20)
hist(rnorm(1000, 0, 3), main="Histogram C", xlim=c(-7,7), ylim=c(0,220), breaks=20)
hist(rnorm(1000), main="Histogram A", xlim=c(-7,7), ylim=c(0,220), xlab="", breaks=20)
hist(rnorm(1000, 0, 2), main="Histogram B", xlim=c(-7,7), ylim=c(0,220), xlab="", breaks=20)
hist(rnorm(1000, 0, 3), main="Histogram C", xlim=c(-7,7), ylim=c(0,220), xlab="", breaks=20)
hist(rnorm(1000), main="Histogram A", xlim=c(-7,7), ylim=c(0,220), xlab="", breaks=20)
hist(rnorm(1000, 0, 2), main="Histogram B", xlim=c(-7,7), ylim=c(0,220), xlab="", breaks=20)
hist(rnorm(1000, 0, 3), main="Histogram C", xlim=c(-7,7), ylim=c(0,220), xlab="", breaks=30)
hist(rnorm(1000), main="Histogram A", xlim=c(-7,7), ylim=c(0,220), xlab="", breaks=10)
hist(rnorm(1000, 0, 2), main="Histogram B", xlim=c(-7,7), ylim=c(0,220), xlab="", breaks=20)
hist(rnorm(1000, 0, 3), main="Histogram C", xlim=c(-7,7), ylim=c(0,220), xlab="", breaks=30)
hist(rnorm(1000), main="Histogram A", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=10)
hist(rnorm(1000, 0, 2), main="Histogram B", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=20)
hist(rnorm(1000, 0, 3), main="Histogram C", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=30)
hist(rnorm(1000), main="Histogram A", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=10)
hist(rnorm(1000, 0, 2), main="Histogram B", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=30)
hist(rnorm(1000, 0, 3), main="Histogram C", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=30)
par(mfrow=c(1,1))
hist(rnorm(1000), main="Histogram A", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=10)
hist(rnorm(1000), main="Histogram A", xlab="", breaks=10)
hist(rnorm(1000), main="Histogram A", xlab="", breaks=15)
hist(rnorm(1000), main="Histogram A", xlab="", breaks=15)
par(mfrow=c(1,3))
hist(rnorm(1000), main="Histogram A", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=10)
hist(rnorm(1000, 0, 2), main="Histogram B", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=30)
hist(rnorm(1000, 0, 3), main="Histogram C", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=30)
hist(rnorm(1000), main="Histogram A", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=10)
hist(rnorm(1000, 0, 2), main="Histogram B", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=30)
hist(rnorm(1000, 0, 3), main="Histogram C", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=30)
hist(rnorm(1000), main="Histogram A", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=10)
hist(rnorm(1000, 0, 2), main="Histogram B", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=30)
hist(rnorm(1000, 0, 3), main="Histogram C", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=30)
hist(rnorm(1000), main="Histogram A", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=10)
hist(rnorm(1000, 0, 2), main="Histogram B", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=30)
hist(rnorm(1000, 0, 3), main="Histogram C", xlim=c(-8,8), ylim=c(0,220), xlab="", breaks=30)
par(mfrow=c(1,1))
hist(rnorm(1000), main="Histogram A", xlab="", breaks=15)
hist(rnorm(1000), main="Histogram A", xlab="", breaks=15)
hist(rnorm(1000), main="Histogram A", xlab="", breaks=15)
hist(rnorm(1000), main="Histogram A", xlab="", breaks=15)
hist(rnorm(1000), main="Histogram A", xlab="", breaks=15)
hist(rnorm(1000), main="Histogram A", xlab="", breaks=15)
hist(rnorm(1000), main="Histogram A", xlab="", breaks=15)
hist(rnorm(1000), main="Histogram A", xlab="", breaks=15)
setwd("~/research/storm_surges/simulations")
# SOURCES
source("../mcmc_functions/mcmc.R") # Metropolis-Gibbs Sampler
source("../mcmc_functions/priors.R")
source("../mcmc_functions/jacobians.R")
source("../mcmc_functions/likelihood.R")
source("../mcmc_functions/posterior.R")
source("../other_functions/sparse.R") # For sparse GP
source("../other_functions/helper_functions.R") # Other misc functions (not part of MCMC)
# Libraries
library(anticlust) # for balanced clustering
library(splitTools) # for stratified splitting
library(twinning) # for multiplet splitting
library(parallel) # For parallel computation
library(doParallel) # For parallel computation
library(foreach) # For parallel computation
library(fields) # Distance matrix calculation
library(mvtnorm)
library(pracma) # For sparse matrix calculation
# Number of clusters for parallel implementation
nCores <- 10
mySeed <- 1234
# Load train and test data
load("data/train.RData")
load("data/test.RData")
nSubj <- length(train$X)
n <- nrow(train$X[[1]])
nTest <- nrow(test$X[[1]])
X <- train$X
Y <- train$Y
S <- train$S
D <- train$D
XTest <- test$X
YTest <- test$Y
STest <- test$S
DTest <- test$D
# Helper function to run subsets in parallel for sketching
sketching_parallel <- function(i) {
results <- mcmc(X = X, Y = Y, D = D, S = S,
nSubj = nSubj,
theta = thetaVals[i],
propSD = c(0.04, 0.3),
nIter = 2000, nBurn = 500,
model = model,
mProp = mProp,
transform = TRUE)
results
}
mVals <- seq(10, 30, by = 10)
mPropVals <- mVals / n
thetaVals <- seq(1, 5, length = nCores)
model <- "full_gp"
test_subj <- 1
MSPE <- numeric(length(mVals))
mVals
n
mPropVals
i=1
mProp <- mPropVals[[i]]
mProp
setwd("~/research/storm_surges/flood")
# Clear environment and free unused memory
rm(list = ls())
gc()
# SOURCES
source("../mcmc_functions/mcmc.R") # Metropolis-Gibbs Sampler
source("../mcmc_functions/priors.R")
source("../mcmc_functions/jacobians.R")
source("../mcmc_functions/likelihood.R")
source("../mcmc_functions/posterior.R")
source("../other_functions/parallel_functions.R") # Parallel wrapper functions
source("../other_functions/helper_functions.R") # Other misc functions (not part of MCMC)
# Libraries
library(parallel) # For parallel computation
library(doParallel) # For parallel computation
library(foreach) # For parallel computation
library(mvtnorm)
library(fields)
library(MBA)
library(anticlust) # for balanced clustering
library(splitTools) # for stratified splitting
# Read in
load("data/flood_data.RData")
# Clusters and seed
nCores <- 2
totalCores <- 10
mySeed <- 123
# Randomly sample indices for train and test data
nObs <- nrow(coords)
pctTrain <- 0.95
n <- nTrain <- floor(pctTrain * nObs)
nTest <- ceiling((1 - pctTrain) * nObs)
set.seed(mySeed)
indexTrain <- sort(sample(1:nObs, nTrain))
indexTest <- sort(setdiff(1:nObs, indexTrain))
indexTrain <- indexTrain[1:500]
nTrain=500
indexTest <- indexTest[1:500]
indexTest <- indexTest[1:100]
nTest=100
storms=1:5
Y <- lapply(storms, \(i) out[i, indexTrain])
X <- lapply(storms, \(i) {
Xintercept <- rep(1, nTrain)
Xstorm <- matrix(rep(unlist(inputs[i, ]), nTrain), ncol = 5, byrow = TRUE)
Xelev <- coords$elev_meters[indexTrain]
X <- cbind(Xintercept, Xstorm, Xelev)
colnames(X) <- c("int", colnames(inputs), "elev")
return(X)
})
S <- as.matrix(coords[indexTrain, 1:2])
D <- rdist(S)
YTest <- lapply(storms, \(i) out[i, indexTest])
XTest <- lapply(storms, \(i) {
Xintercept <- rep(1, nTest)
Xstorm <- matrix(rep(unlist(inputs[i, ]), nTest), ncol = 5, byrow = TRUE)
Xelev <- coords$elev_meters[indexTest]
X <- cbind(Xintercept, Xstorm, Xelev)
colnames(X) <- c("int", colnames(inputs), "elev")
return(X)
})
STest <- as.matrix(coords[indexTest, 1:2])
DTest <- rdist(STest)
# Sketching
thetaVals <- seq(10, 100, length = totalCores)
model <- "full_gp"
mProp <- 0.01
nSubj <- length(storms)
i=1
sketching_parallel(i)
test_subj <- 1
sketching_parallel(i)
sketching_parallel(i)
cl <- makeCluster(nCores)
registerDoParallel(cl)
strt <- Sys.time()
set.seed(mySeed)
obj <- foreach(i = 1:totalCores, .packages = "mvtnorm") %dopar% sketching_parallel(i)
final.time <- Sys.time() - strt
stopCluster(cl)
if (file.exists(".RData")) {
file.remove(".RData")
}
gc()
flood_results_sketching <- wasserstein(nChains = totalCores, method = "sketching")
flood_results_sketching <- wasserstein(nChains = totalCores,
method = "sketching",
model = "full_gp",
splitType = NULL,
time = final.time)
saveRDS(flood_results_sketching, paste0("results/flood_results_sketching.RDS"))

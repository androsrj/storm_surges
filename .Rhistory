# Report cumulative sum for x less than 10
x = seq(1, 30, 1)
y = seq(0, 1, length = 30)
z = x + y
z[x < 10]
cusum(z[x < 10])
M1 = diag(5) # creating diagonal matrix
cumsum(z[x < 10])
z[x < 10]
z[x < 10]
M1 = diag(5) # creating diagonal matrix
lower.tri(M1, diag = TRUE) # creating triangular matrix
x = seq(1, 9, 1)
M2 = matrix(x, nrow = 3, ncol = 3)
dim(M2)
x = 1:9
dim(x) = c(3, 3)
x
# Creating Matrices by Some Criterion
x1 = seq(1, 5, 1)
x2 = seq(2, (2*5), 2)
x3 = seq(3, (3*5), 3)
x4 = seq(4, (4*5), 4)
x5 = seq(5, (5*5), 5)
M = cbind(x1, x2, x3, x4, x5)
# Extraction of Elements
M[1, 2] # extracts element from the 1st row and 2nd column
M[1, ] # extracts 1st row
M[, 3] # extracts 3rd column
# Row & Column Operations
apply(M, 1, mean ) # 1 for row operations
apply(M, 2, mean ) # 2 for column operations
# Extract all elements less than 7 from 2nd column of M
y = M[, 2]
y[y < 7]
# Basic Operations
X1 + X2 # element wise addition
X1 - X2 # element wise subtraction
X1 * X2 # element wise multiplication
x1
x2
M
# Dataframes in R
day.num = seq(1, 7, 1)
day.name = c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat")
week = data.frame(day.num, day.name)
week
week.mat = as.matrix( week )
is.matrix(week.mat) # TRUE
# Accessing elements
head(airquality)
is.data.frame(airquality)
airquality$Wind
airquality$Temp
# Creating lists
y = vector(mode = "list")
y[[1]] = c(1, 2, 3)
y[[2]] = c(5, "apple", 6, "banana", 7, "cherry")
y[[3]] = c("Welcome to 2nd lecture - intro to R")
y[[4]] = matrix (c(1, 2, 3, 4), nrow = 2)
y[[5]] = y[[1]] + 10
y
# Giving names
names(y) = c("numbers", "mix", "sentence", "matrix1", "matrix2")
# Nested lists
z = vector(mode = "list")
z[[1]] = vector(mode = "list")
z[[1]][[1]] = c("Monday")
z[[1]][[2]] = c("Tuesday")
z[[1]][[3]] = c("Wednesday")
z[[1]][[4]] = c("Thursday")
z[[1]][[5]] = c("Friday")
z[[2]] = vector(mode = "list")
z[[2]][[1]] = c("Saturday")
z[[2]][[2]] = c("Sunday")
z[[3]] = list(seq(0.1 , 0.2 , length = 10))
names(z) = c("weekdays", "weekend", "sequence")
z
# Accessing elements
z$weekdays[[5]]
z$weekend[[2]]
z$sequence[[1]][5]
# If-else statement
x = 10
if (x %% 2 == 0) {
y = runif(n = 1, min = 0, max = 1)
} else {
y = runif(n = 1, min = 2, max = 4)
}
y
ifelse(x %% 2 == 0, runif(1, 0, 1), runif(1, 2, 4))
x = 15
if (x %% 2 == 0) {
y = runif(n = 1, min = 0, max = 1)
} else if (x %% 3 == 0) {
y = 0
} else {
y = runif(n = 1, min = 2, max = 4)
}
y
# Writing loops
count = 1 # Initialize count
z = NULL
while (count <= 15)
# The task within while loop is executed until
# count becomes 16
{
# Creating a vector
x = c(1:count)
# Storing 1st element of a random permutation
y = sample(x)[1]
# Storing all the 1st elements
# of each random permutation
z = c(z, y)
# Increasing the count
count = count + 1
# Extremely important step to run the loop
}
z
for (i in 1:10) {
if(i %% 2 == 0) {
print(i)
} else {
print(0)
}
}
# Fibonacci sequence
f = NULL
f[1] = 1
f[2] = 1
for (j in 3:20) {
f[j] = f[j - 1] + f[j - 2]
}
f
# sapply and lapply
sapply (1:5 , function(i) {
mean(runif(10 , min = i, max = i + 1))
})
lapply (1:5 , function(i) {
mean(runif(10 , min = i, max = i + 1))
})
?CO2
head(CO2)
is.data.frame(CO2)
CO2$Plant
CO2$Type
CO2$Treatment
CO2$conc
CO2$uptake
# Extract the update values for which Plant equals Qn1
CO2$uptake[CO2$Plant == "Qn1"]
# Extract the update values for which Plant equals Qn1 and Type equals Quebec. Also calculate the mean
CO2$uptake[(CO2$Plant == "Qn1") & (CO2$Type == "Quebec")]
mean(CO2$uptake[(CO2$Plant == "Qn1") & (CO2$Type == "Quebec")])
# Calculate how many uptake values are there which are less than 25
sum(ifelse(CO2$uptake <= 25, 1, 0))
# For loop
count1 = NULL
for(k in 1:length(CO2$uptake)) {
if(CO2$Treatment[k] == "chilled" & CO2$uptake[k] <= 25) {
count1[k] = 1
} else {
count1[k] = 0
}
}
sum(count1)
# While loop
k = 1
count2 = NULL
while (k <= length(CO2$uptake)) {
if(CO2$Treatment[k] == "chilled" & CO2$uptake[k] <= 25) {
count2[k] = 1
} else {
count2[k] = 0
}
k = k + 1
}
sum(count2)
# Calculate the average distance taken to stop given the speed of the cars using lapply and sapply
speed = unique(cars$speed)
lapply(1:length(speed), function(h){
x = mean(cars$dist[cars$speed == speed[h]])
return(x)
})
speed = unique(cars$speed)
sapply(1:length(speed), function(h){
y = mean(cars$dist[cars$speed == speed[h]])
return(y)
})
# Writing simple functions
average.sd = function(n) {
# Check if n >= 10
if(n >= 10) {
x = sample(1:n, size = 10, replace = FALSE)
} else{
# if false generate error message
stop("Enter number more than 10")
}
# Calculate mean and standard deviation
y1 = mean(x)
y2 = var(x)
y = c(y1, y2)
return(y) # Return statement
}
average.sd(4) # Function calls
average.sd(11)
average.sd(20)
# Function body
f = function(x) {
return(x^2 - 3*x + 4)
}
# Generate x values to evaluate the function
xval = seq(0, 1, length = 20)
yval = f(x = xval) # Function call
# Plot the curve
plot(xval, yval, type = "l", xlab = "x", ylab = "f(x)")
# Data Visualization
# Scatter Plot
x = cars$speed
y = cars$dist
plot(x, y, col = "maroon", pch = 16, xlab = "speed", ylab = "distance",
main = "Scatter Plot of distance vs speed")
library (ggplot2)
ggplot(cars, aes(x = speed, y = dist)) + geom_point () + ggtitle (" Scatter Plot of distance vs speed ")
# Line diagram
ggplot(cars, aes(x = speed, y = dist)) + geom_line() + ggtitle("Line Diagram of distance vs speed")
# Bar Plot
# Calculate the average mpg values corresponding
# to each cylinder value
# Three categories
mpg1 = mean(mtcars$mpg[mtcars$cyl == 4])
mpg2 = mean(mtcars$mpg[mtcars$cyl == 6])
mpg3 = mean(mtcars$mpg[mtcars$cyl == 8])
barplot(c(mpg1, mpg2, mpg3) ~ c(4, 6, 8),
xlab = "mtcars$cyl",
ylab = "average mpg per cyl",
ylim = c(0, 28),
col = "maroon",  # color of the bars
width = c(5, 5, 5),  # width of the bars
space = 2, # bar spacing
main = "Barplot for average mpg vs cyl")
cyl = c(4, 6, 8)
avg.mpg = c(mpg1, mpg2, mpg3)
data = data.frame(cyl, avg.mpg)
ggplot(data, aes(y = avg.mpg , x = cyl)) +
geom_bar(position = "dodge", stat="identity") +
ggtitle("Barplot for average mpg vs cyl for mtcars") +
ylim(c(0, 28))
# Divided Bar Diagram
mpg1 = mean(mtcars$mpg[mtcars$cyl == 4])
mpg2 = mean(mtcars$mpg[mtcars$cyl == 6])
mpg3 = mean(mtcars$mpg[mtcars$cyl == 8])
disp1 = mean(mtcars$disp[mtcars$cyl == 4])
disp2 = mean(mtcars$disp[mtcars$cyl == 6])
disp3 = mean(mtcars$disp[mtcars$cyl == 8])
hp1 = mean(mtcars$hp[mtcars$cyl == 4])
hp2 = mean(mtcars$hp[mtcars$cyl == 6])
hp3 = mean(mtcars$hp[mtcars$cyl == 8])
qsec1 = mean(mtcars$qsec[mtcars$cyl == 4])
qsec2 = mean(mtcars$qsec[mtcars$cyl == 6])
qsec3 = mean(mtcars$qsec[mtcars$cyl == 8])
cyl = c(4, 6, 8)
avg.mpg = c(mpg1, mpg2, mpg3)
avg.disp = c(disp1, disp2, disp3)
avg.hp = c(hp1, hp2, hp3)
avg.qsec = c(qsec1, qsec2, qsec3)
mtcars.mat = rbind(avg.mpg, avg.disp, avg.hp, avg.qsec)
colnames(mtcars.mat) = c("4", "6", "8")
barplot(mtcars.mat,
col = c("skyblue", "deepskyblue2", "dodgerblue4", "blue"),
ylim = c(0, 650),
legend.text = rownames(mtcars.mat),
args.legend = list(x = "topleft"),
main = "Divided Barplot for mtcars")
# Multiple Bar Diagram
barplot(mtcars.mat,
col = c("skyblue", "deepskyblue2", "dodgerblue4", "blue"),
ylim = c(0, 350),
legend.text = rownames(mtcars.mat),
args.legend = list(x = "topleft"),
main = "Multiple Bardiagram for mtcars",
beside = TRUE)
# Pie Diagram
# Calculating averages
food.tobacco = mean(USPersonalExpenditure[1, ])
house.opr = mean(USPersonalExpenditure[2, ])
med.health = mean(USPersonalExpenditure[3, ])
per.care = mean(USPersonalExpenditure[4, ])
prvt.edu = mean(USPersonalExpenditure[5, ])
# Pie diagram
avg.exp = c(food.tobacco, house.opr, med.health, per.care, prvt.edu)
categories = c("food.tobacco", "household.operation", "medical.health", "personal.care", "private.education")
pie(avg.exp, labels = categories, main = "Average personal expenditures over years")
# Box plot
boxplot(mtcars$hp ~ as.factor(mtcars$cyl), col = "skyblue",
xlab = "Cylinders",
ylab = "Horse Power",
main = "Boxplot for hp by cyl for mtcars")
# Histogram
hist(faithful$eruptions, freq = FALSE,
xlab = "Eruption time",
main = "Histogram for eruptions data")
pie(avg.exp, labels = categories, main = "Average personal expenditures over years")
setwd("~/research/storm_surges")
# Clear environment and free unused memory
rm(list = ls())
gc()
# SOURCES
source("mcmc_functions/flood_mcmc.R") # Metropolis-Gibbs Sampler
source("mcmc_functions/priors.R")
source("mcmc_functions/jacobians.R")
source("mcmc_functions/likelihood.R")
source("mcmc_functions/posterior.R")
source("other_functions/parallel_functions.R") # Parallel wrapper functions
source("other_functions/helper_functions.R") # Other misc functions (not part of MCMC)
# Libraries
library(parallel) # For parallel computation
library(doParallel) # For parallel computation
library(foreach) # For parallel computation
library(mvtnorm)
library(fields)
library(MBA)
library(anticlust) # for balanced clustering
library(splitTools) # for stratified splitting
# Read in
load("data/flood_data.RData")
# Clusters and seed
nCores <- 2
totalCores <- 4
mySeed <- 123
# Randomly sample indices for train and test data
nObs <- nrow(coords)
pctTrain <- 0.02
n <- nTrain <- floor(pctTrain * nObs)
nTest <- ceiling(.02 * nObs)
set.seed(mySeed)
indexTrain <- sort(sample(1:nObs, nTrain))
indexTest <- sort(setdiff(1:nObs, indexTrain))
.02*nObs
nTest <- ceiling(.02 * nObs)
indexTest <- sort(sample(1:nObs, nTest))
indexTrain <- sort(sample(1:nObs, nTrain))
indexTest <- sort(sample(1:nObs, nTest))
# Divide using train and test indices
storms <- 1:50
YTrain <- lapply(storms, \(i) out[i, indexTrain])
XTrain <- lapply(storms, \(i) {
Xintercept <- rep(1, nTrain)
Xstorm <- matrix(rep(unlist(inputs[i, ]), nTrain), ncol = 5, byrow = TRUE)
Xelev <- coords$elev_meters[indexTrain]
X <- cbind(Xintercept, Xstorm, Xelev)
colnames(X) <- c("int", colnames(inputs), "elev")
return(X)
})
STrain <- as.matrix(coords[indexTrain, 1:2])
DTrain <- rdist(STrain)
YTest <- lapply(storms, \(i) out[i, indexTest])
XTest <- lapply(storms, \(i) {
Xintercept <- rep(1, nTest)
Xstorm <- matrix(rep(unlist(inputs[i, ]), nTest), ncol = 5, byrow = TRUE)
Xelev <- coords$elev_meters[indexTest]
X <- cbind(Xintercept, Xstorm, Xelev)
colnames(X) <- c("int", colnames(inputs), "elev")
return(X)
})
STest <- as.matrix(coords[indexTest, 1:2])
DTest <- rdist(STest)
# D&C, subdomain split
indexSubd <- balanced_clustering(STrain, totalCores)
subsetsX <- lapply(1:totalCores, function(k) {
lapply(storms, function(s) XTrain[[s]][which(indexSubd == k), ])
})
subsetsY <- lapply(1:totalCores, function(k) {
lapply(storms, function(s) YTrain[[s]][which(indexSubd == k)])
})
subsetsD <- lapply(1:totalCores, function(k) {
lapply(storms, function(s) DTrain[[s]][which(indexSubd == k), which(indexSubd == k)])
})
subsetsD <- lapply(1:totalCores, function(k) DTrain[which(indexSubd == k), which(indexSubd == k)])
cl <- makeCluster(nCores)
registerDoParallel(cl)
strt <- Sys.time()
set.seed(mySeed)
obj <- foreach(i = 1:totalCores, .packages = "mvtnorm") %dopar% subdomains_parallel(i)
i=1
length(subsetsX[[i]])
length(subsetsY[[i]])
length(subsetsD[[i]])
dim(subsetsD[[i]])
subdomains_parallel(1)
traceback()
X=subsetsX[[1]]
# Dimensions
nObs <- nrow(X[[1]])
nTrain <- nObs - nKnots
p <- ncol(X[[1]])
nTrain <- nObs
nObs
nTrain
mProp
mProp=0.1
mProp=0.01
m <<- round(mProp * nTrain)
m
dim(DTrain)
nObs
nTrain
setwd("~/research/sketching/paper/figures")
# SURFACE PLOTS USING MBA PACKAGE
library(MBA)
source("../../code/other_functions/spatial_data.R")
load("../../code/data/train.RData")
nKnots <- 50
n <- length(train$Y) - nKnots
trueTheta <- 3
# True spatial surface
trueY <- train$Y[1:n]
trueCoords <- train$S[1:n, ]
pred.surf <-  mba.surf(cbind(trueCoords, trueY), no.X=100, no.Y=100, extend=T)$xyz.est
image(pred.surf, xaxs ="r", yaxs = "r", main="")
image(pred.surf, xaxs ="r", yaxs = "r", main="", legend.only = TRUE)
library(MBA)
warnings()
library(MBA)
?image
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", legend.only = TRUE)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="")
warnings()
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="")
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12, "YlOrRd", rev=TRUE))
setwd("~/research/storm_surges")
library(MBA)
# Read in
load("data/flood_data.RData")
# Surface plot of elevation
pred.surf <-  mba.surf(coords, no.X=100, no.Y=100, extend=T)$xyz.est
image(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12, "terrain", rev = TRUE))
# Read in results and test points
flood_results <- readRDS("results/flood_final_results.RDS")
indices <- readRDS("results/data_split.RDS")
indexTrain <- indices[[1]]
indexTest <- indices[[2]]
# Surface plot for actual water level of storm 1 at all test points
trueY <- colMeans(out)[indexTest]
pred.surf <-  mba.surf(cbind(coords[indexTest, 1:2], trueY), no.X=100, no.Y=100, extend=T)$xyz.est
image(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12, "terrain", rev = TRUE))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12, "YlOrRd", rev=TRUE))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="")
hcl.pals()
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Greens", rev=TRUE))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)")
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.cex=5)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.cex=2)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.args = 2)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.args = list(cex=2))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.args = list(cex=5))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.shrink = 1
)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.shrink = 1)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.shrink = 5)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.shrink = 2)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.shrink = 0.2)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.shrink = 1)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.shrink = -1)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.shrink = 0)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.shrink = 0.1)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.shrink = 0.2)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.shrink = 0.5)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)")
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", cex.axis=2, col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)")
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", cex.legend=2, col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)")
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", cex.sub=2, col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)")
warnings()
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", cex.sub=2, col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)")
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.mar = 2)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.mar = 10)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.args = list(cex = 5))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.args = list(text = "5", cex = 5))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.args=list( text="unknown units",
col="magenta", cex=1.5, side=4, line=2))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.args=list( text="unknown units",
col="magenta", cex=1.5, side=4, line=2))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.cex=3)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)", legend.cex=3)
image(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12, "terrain", rev = TRUE))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), legend.cex=2)
1:3+1
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), axis.args = list(at=0:5+1, labels=1:6))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), axis.args = list(at=1:5+1, labels=1:6))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), axis.args = list(at=1:5+1, labels=1:5))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), axis.args = list(at=1:5+1, labels=1:5))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), axis.args = list(at=1:5, labels=1:5))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), axis.args = list(at=1:5, labels=1:5))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), axis.args = list(at=1:5, labels=1:5, cex=3))
par("cex")
par(cex=2)
par("cex")
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(6, "Terrain", rev=TRUE), axis.args = list(at=1:5, labels=1:5, cex=3))
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)")
par(cex=0.5)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)")
par(cex=0.5)
par(cex=2)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)")
par(cex=1.5)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)")
par(cex=1.3)
image.plot(pred.surf, xaxs ="r", yaxs = "r", main="", col = hcl.colors(12, "Terrain", rev=TRUE), legend.lab = "Water Level (meters)")
gc()
